# 常用端口+TCP&UDP报文格式

> 总览：
> 
> 
> UDP：无连接（不可靠），可广播，时延小→适用于小包
> 
> TCP：有连接（可靠），不可广播，时延大→适用于大包
> 

# 一、端口与套接字

【定义】

端口即传输层提供给进程的服务访问点

当我们想要访问远端主机的某程序时，需指向`ip:端口号`，该格式叫“套接字(Socket)”，该程序也可以视为是一个“套接字实体”

【端口号】

用16bit描述一个端口，共65536种可能取值。

端口的作用域是当前主机（也可以视为当前ip）

> 所以：在A主机的1000端口和在B主机的1000端口不是同一个
> 

【熟知端口号】

- 一般默认将0-1023这段范围的端口号设置为一些协议通讯时的默认端口号，叫“熟知端口号”
    - 常见协议对应的端口号如下：
        
        
        | FTP | SSH/SFTP | TELNET | SMTP | DNS | TFTP | HTTP | SNTP |
        | --- | --- | --- | --- | --- | --- | --- | --- |
        | 21 | 22 | 23 | 25 | 53 | 69 | 80 | 161 |
        
        其中：
        
        | 服务器监听的端口 | 80/8080/8888 |
        | --- | --- |
        | 访问外界的HTTPS服务器 | 443 |
        
        > WWW代理服务器，说白了就是浏览器
        > 
        > 
        > 其中，80端口是浏览器的对外界HTTP服务器的正常访问，8080是本地调试浏览器时去访问本地服务器，8888是抓包工具（需要在浏览器上先配置好，每次有流量转发一份到8888端口，然后抓包工具监听8888端口，这样就能截获流量，抓包工具构造包上传时也是类似原理）
        > 
    
    当主机在做某个协议的服务端时，通常就是会默认监控该协议对应的端口
    
- 1024-49151这段范围的端口号则可以被应用程序登记使用（为了不和其他应用程序的端口号“撞车”，所以要去标准化机构IANA里面做个登记）
    - 常见应用程序对应的端口号如下：
        
        
        | Tomcat | Oracle | Mysql | SQL sever | QQ |
        | --- | --- | --- | --- | --- |
        | 8080 | 1521 | 3306 | 1433 | 4000 |
        
        数据库相关：
        
        | mySQL | 3306 |
        | --- | --- |
        | Microsoft SQL sever | 1433 |
        | oracle | 1521 |
        | PostgreSQL | 5432 |
        | Redis | 6379 |
        
        > PostgreSQL是一款开源的关系型数据库管理系统
        > 
        > 
        > Redis是一款主要用于内存数据缓存的数据库管理系统
        > 
        
        邮件相关：
        
        | POP3 | 110 |
        | --- | --- |
        | smtp | 25 |
        | POP3S | 995 |
        | smtps | 465 |
        
        其他：
        
        | FTP文件传输 | 21 |
        | --- | --- |
        | ssh加密文件传输 | 22 |
        | telnet远程登录 | 23 |
        | socks | 1080 |
        | RDP远程桌面控制 | 3389 |
        | SMB文件共享协议 | 旧版139，新版445 |
        
        > telnet常见于路由、交换机
        > 
        > 
        > socks用于客户端与代理服务器的通信
        > 
        > SMB常用于windows局域网内的共享文件夹
        > 
- 49152-65535这段范围的端口号叫”短暂端口号”，一般是由一些没登记的应用程序使用，但实际生产中其实没有太严格地做区分

【查看linux系统中的端口号占用情况】

- 相关指令如下：
    
    查看某个进程占用了哪个端口：
    `ps -ef |grep tomcat`
    查看某个端口被哪个进程占用：
    `lsof  -i:8080`
    查看所有端口的被占用情况：
    `lsof  -i:8080`
    杀死正在占用某个端口的进程：
    `kill -9 PID`或`kill -9 端口号`
    

# 二、UDP协议

【定义】

无连接，不可靠，可广播，无拥塞控制，首部开销小

【结构】

总体结构如下：

![Untitled](%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3+TCP&UDP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%20b99f22b79bf54ebd9dff3cecddc45a3a/Untitled.png)

其中，UDP首部如下，其大小仅有8B：

![Untitled](%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3+TCP&UDP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%20b99f22b79bf54ebd9dff3cecddc45a3a/Untitled%201.png)

各字段注解如下：

- 源端口号：有时候可以直接不填（全填0即可）
- 数据报长度：整个UDP数据报长，包括UDP头和报文内容的长度
- 校验和：这个也不是必须的，如果不开启校验，就全填0即可

【应用】

由于UDP头结构过于简单，不能支持差错控制（不丢失&重复&按序到达）功能，所以我们规定：

UDP只用于发送那种可以不需要拆分的应用层小报文，也就是说每次UDP只需发送一个包~

【差错反馈】

如果是目的端口写错或目的端口的进程被杀，对方就会返回一个ICMP的“端口不达”报文

【例题】

- 例题如下：
    
    判断：
    
    UDP是全双工
    
    解：
    
    错，因为UDP是无连接，所以也就无链路，不存在工不工的
    

# 三、UDP的校验和算法

【定义】

用于校验UDP头部是否被修改

【过程】

- 发送端进行如下操作：
    
    1、先在UDP首部前面加上一个抽象的“伪首部”，结构如下：
    
    ![Untitled](%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3+TCP&UDP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%20b99f22b79bf54ebd9dff3cecddc45a3a/Untitled%202.png)
    
    > 其中，0是被保留，17表示UDP
    > 
    
    2、把校验和字段用全0填充，再把UDP报数据体部分向4B对齐（填0使对齐）
    
    3、把“伪首部+首部+数据部分”当做一块，然后分组（16bit一组）后求和，再将求和的结果求反码，最终得到校验和。如下：
    
    ![Untitled](%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3+TCP&UDP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%20b99f22b79bf54ebd9dff3cecddc45a3a/Untitled%203.png)
    
    4、然后各个组做二进制求和（超过16bit就溢出丢弃的），然后将求和结果去反码，填入校验和
    

【接收端】

把“伪首部+首部+数据部分”当做一块，分组求和，如果结果全为1，就是无差错

> 因为这里除了校验和之外的其他组相加，得到的是当前校验和的反码，再加上校验和，就是一个数的反码和他自己相加，结果必然是全1
> 

# 四、TCP协议

【定义】

有连接（可靠），点对点（不广播），差错控制（不丢失&重复&按序到达）

其通常用于大报文传输，会将大报文拆分成多份，每份封装成一个TCP报文段

【结构】

报文头结构如下：

![淡黄色表示首部可选部分](%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3+TCP&UDP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%20b99f22b79bf54ebd9dff3cecddc45a3a/Untitled%204.png)

淡黄色表示首部可选部分

其中各个字段的介绍：

- 分报相关
    - **序号**：
        
        该字段在发送端发送的报文中有意义
        
        我们按照0,1,2,...给拆分前的大报文的data部分每个字节赋一个下标。“序号”这个域存储了其所属报文段data部分的第一个字节的下标。
        
        > 例如：有一个大报文30B，拆成两个报文段各传15B，则第一个报文的“序号”为0，第二个报文的“序号”为15
        > 
        
        > 注：该字段只有在确认位ACK=1时才有意义
        > 
    - **确认号**：
        
        该字段在接受端给发送端的响应报文中有意义
        
        表示期望收到的下一个报文段的“序号”，这样可以保证在丢包时让发送方进行重发
        
        > 假如A要发一个大报文有6000B，它将报文分成三份，第一份是第0~1999B，第二份是第2000到第3999B，第三份是第4000到第5999B
        > 
        > 
        > 假如A发了三份，但因为丢包，B只收到了第一份和第三份，他就会返回一个确认号为2000的ACK包，以令A进行第二第三份报文段的重发
        > 
    - **数据偏移：**
        
        4位，表示：首部（含首部可选部分）长度，以4B为单位。即“首部长度=数据偏移值×4”
        
- 握手挥手相关
    - **确认位ACK+同步位SYN：**
        
        确认位表示连接已建立，确认位为1时表示确认号是有效的；
        
        同步位表示正在尝试建立连接；
        
        > 所以，握手的请求建立连接时和同意接受连接时：ACK=0，SYN=1
        > 
        > 
        > 连接建立后：ACK=1，SYN=0
        > 
    - **复位RST：**
        
        为1时表示TCP连接出错，需释放后重连
        
    - **终止位FIN：**
        
        为1时表示此报文段已发完，请求释放连接（因为要释放资源占用）
        
- 紧急处理相关
    - **紧急位URG+紧急指针：**
        
        紧急位若为1，表示这个报里有“紧急数据”，接收端读“紧急指针”索引到紧急数据的位置。该紧急数据将不进接收端的缓存而是直接插队传递给进程。
        
    - **推送位PSH：**
        
        为1时表示急，要求接收端不收满缓存就直接交付给进程
        
- 流量控制、可靠传输相关
    - **窗口：**
        
        用于拥塞控制，其具体机制内容见另一篇笔记
        
    - **检验和：**
        
        和UDP的一样实现逻辑，区别在于伪首部的第四个域的值为6（表示TCP）：