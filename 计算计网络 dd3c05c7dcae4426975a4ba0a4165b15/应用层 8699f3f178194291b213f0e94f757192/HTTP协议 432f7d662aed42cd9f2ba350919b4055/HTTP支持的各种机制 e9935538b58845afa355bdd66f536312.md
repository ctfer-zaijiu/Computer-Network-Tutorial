# HTTP支持的各种机制

# 一、访问控制机制

### 1-cookie机制

【定义】

Cookie 是一种在客户端（浏览器）存储的一段信息，用于跟踪用户的状态和识别用户。

其通过浏览器在每次请求中自动被发送到服务器。

【相关字段】

- 客户端：
    
    1、**Cookie（携带cookie）：**
    
    - 作用： 包含先前由服务器通过 Set-Cookie 头部设置的 HTTP cookie。
    - 例子： `Cookie: name=value; name2=value2`
- 服务端：
    
    1、**Set-Cookie（设置Cookie）:**
    
    - 作用： 服务器通过这个头域在客户端设置Cookie。
    - 例子： `Set-Cookie: sessionId=abc123; Expires=Sat, 02 Oct 2023 16:00:00 GMT`

【实现过程】

服务器通过在 HTTP 响应头中添加 `Set-Cookie` 字段将 Cookie 传递给客户端。

客户端浏览器会在后续的每个请求中自动包含这些 Cookie。

【应用-优缺点】

这是一种在一些老网站常用的访问控制方案

其主要特点是实现简单，但是可能容易受到跨站脚本攻击（XSS）和跨站请求伪造攻击（CSRF）等安全威胁。

### 2-OAuth 2.0机制

【定义】

该机制通过让客户端携带“授权码”获得令牌。实现使用户可以无需账号密码登录服务端，且其账号密码不会被客户端记录。

其授权码的传递是基于一些该协议自定义的传参，被携带在报文的body部分，而不是借用http的头部字段。

但其最后一步的令牌的携带需要通过请求报文头部的Authorization字段。

【相关字段】

- 客户端：
    - **Authorization（携带令牌）：**
        - 作用： 包含客户端提供给服务器的身份验证凭据，通常用于进行身份验证。
        - 例子： `Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`
- 服务端：
    - **WWW-Authenticate（身份验证质询）:**
        - 作用： 服务器在返回401未授权状态码时使用，指定客户端应该如何进行身份验证。
        - 例子： `WWW-Authenticate: Basic realm="Example Realm"`

【实现过程】

1. **用户首次登录，通过账号密码登录到服务端**
2. **服务器通过重定向URI的查询字段携带授权码给到客户端**
    
    服务器自己生成并存储一份授权码，同时给客户端发一份授权码。
    
    这种发授权码的方式是这么实现的：
    
    服务端对客户端请求重定向到授权码的授予接口，并使客户端发送一个携带授权码获取参数的请求包
    
    授予接口对该请求包给出一个响应包，响应包中的授权码获取参数的值被设置为授权码
    
    授权码的有效期较长，客户端获得该授权码后，存储之，其可以作为代替账号密码的信息向服务端请求令牌。
    
3. **用户后续登录，通过POST请求传参携带授权码给到服务端获得令牌**
    - 携带授权码的请求通常是一个POST请求，携带以下参数：
        - `grant_type`: 必须是 `"authorization_code"`，指明使用授权码授权流程。
        - `code`: 包含获得的授权码。
        - `redirect_uri`: 必须与获取授权码时使用的重定向 URI 一致。
    - 携带令牌的响应通常是一个 JSON 对象，包含以下信息：
        
        ```json
        {
          "access_token": "YOUR_ACCESS_TOKEN",
          "token_type": "Bearer",
          "expires_in": 3600,
          "refresh_token": "YOUR_REFRESH_TOKEN",
          "scope": "read write"
        }
        ```
        
    
    > 然后携带令牌的请求就可以获得资源访问权限，但是令牌的有效期较短（用于防止重放攻击），一旦令牌失效就需要再通过授权码获得令牌
    > 
4. **用户通过Authorization字段携带令牌访问资源**

【应用+优缺点】

这是一种更为常用的访问控制方案，因为它有以下优点：

1. **安全性：** OAuth 2.0 提供了更多的安全特性，例如令牌的时效性、范围控制等，相对较为安全。
2. **适用于多应用：** OAuth 2.0 支持多应用系统，并能够在不同的应用之间共享用户身份信息，实现单点登录。
3. **支持第三方授权：** OAuth 2.0 支持第三方授权，使得用户可以授权第三方应用访问他们的资源。

# 二、字节范围请求机制

【定义】

HTTP的字节范围请求机制允许客户端请求资源的特定范围或部分，而不是整个资源。这对于大文件的断点续传、多线程下载和只需要资源的一部分的情况非常有用。

请求包中可以选定多个字节范围进行“多范围请求”，如果服务端支持的话会返回多个响应包，每个响应包对应一个范围。

【相关字段】

- 客户端：
    - **Range头字段：**
        
        客户端在HTTP请求中使用`Range`头字段指定所需的字节范围。
        
        范围的格式通常是`bytes=start-end`，可以是多个范围，用逗号分隔。
        
        > 例如，`Range: bytes=0-499`表示请求前500个字节。
        > 
- 服务端：
    - **服务器响应状态码：**
        
        如果服务器支持字节范围请求并能够满足请求，它会以状态码`206 Partial Content`进行响应。这表示服务器成功地返回了客户端请求的部分内容。
        
    - **Content-Range头字段：**
        
        在响应中，服务器使用`Content-Range`头字段指定返回的实际字节范围。
        
        > 例如，`Content-Range: bytes 0-499/10000`表示返回的是文件的前500字节，而整个文件的长度是10000字节。这个信息有助于客户端知道它所接收的是整体资源的哪个部分。
        > 

# 三、目标重定向机制

【定义】

服务器在接收到客户端请求后，返回一个特定的状态码，告诉客户端需要重新定位到另一个URL来获取资源。

这个过程通常用于处理一些特定的情况，比如：资源被移动、请求的URL发生变化等。

【相关字段】

- 客户端：
    
    1、**Referer (引用页)：**
    
    - 作用： 指示请求的来源页面，即用户是从哪个页面跳转或提交的请求。
    - 例子： `Referer: https://www.example.com/previous-page`
- 服务端：
    - **服务器响应状态码：**
        
        可以取以下的这些值：
        
        1. 303 See Other（查看其他位置）：表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。
        2. 302 Found（搜索引擎无关的临时重定向）：表示所请求的资源已被分配了新的临时URI，将来的请求应该使用新的URI，但是搜索引擎应该继续使用原有的URI。
        3. 307 Temporary Redirect（临时重定向）：表示请求的资源已被分配了新的临时URI，将来的请求应该使用新的URI。
        4. 301 Moved Permanently（永久重定向）：表示所请求的资源已被分配了新的永久URI，将来的请求应该使用新的URI。
            
            它可能会导致浏览器将POST请求转变为GET请求，所以不如308安全。
            
        5. 308 Permanent Redirect（更安全的永久重定向）：表示请求的资源已被分配了新的永久URI，将来的请求应该使用新的URI。
    - **Location（重定向位置）:**
        - 作用： 用于将客户端重定向到另一个位置。
        - 例子： `Location: https://www.example.com/new-location`

【实现过程】

**1、服务端要求客户端进行重定向**

服务端会向客户端发送一个报文，其中的响应状态码表示要做重定向，Location表示重定向到哪个url

**2、客户端按照重定向要求修改请求包的目标**

同时在Referer字段中标明重定向前的那个url