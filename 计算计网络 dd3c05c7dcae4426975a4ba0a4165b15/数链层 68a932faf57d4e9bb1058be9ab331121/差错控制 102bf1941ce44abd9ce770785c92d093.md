# 差错控制

# 一、相关基本概念

**重发：**

丢包之后发送端重发

数链层只规定了什么情况下要重发，但是没有规定如何重发，如何重发是网络层的工作

**链路&数据链路：**

链路便是物理链路；

数据链路则是：不管用什么物理方式实现出来的链路，我统一都抽象地认为是一条通道（即忽略物理实现细节）

**差错控制：**

本质就是通过在要发送的信息旁边附上一块冗余信息，以实现：

1.报错 2.纠错（定位到错误位置）

**位错&帧错：**

位错即比特位错，由物理层进行削减，由数据链路层负责监控+防止

帧错即帧的丢失、重复、失序，由传输层负责监控+防止

**位错的2种成因：**

- 随机噪声（热噪声）：来自线路的干扰损耗，平时传输都会有的
- 冲击噪声：某种突然事故现象（如太阳中子星爆炸）照成的影响

**异或：**

即“同0异1”

**异或除法：**

通过如↓图方式进行不断异或除，直到得到一个商和一个余数：

![Untitled](%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%20102bf1941ce44abd9ce770785c92d093/Untitled.png)

二进制的多项式表达：

二进制数$10011$，可对应成多项式：$1*2^{4}+0*2^{3}+0*2^{2}+1*2^{1}+1*2^{0}$

多项式的阶数：

多项式的阶数为其最高位的次数，如图：

![Untitled](%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%20102bf1941ce44abd9ce770785c92d093/Untitled%201.png)

> 此处有一个小坑：**若二进制的最左边的1是第n位，则其阶数应为n-1**，因为其对应的多项式应为$2^{n-1}$
> 

# 二、常见的差错控制方案（3种）

### 1-****奇偶校验码检错****

【定义】

这个是只能测出有奇数个bit位发生变化，而不能检出偶数个bit位发生变化。
所以不能保证100%检出错误，所以基本不用。

【原理】

以某1DWORD（8位）数据为例

- **发送端**有以下两种校验方案：
    
    奇校验方案：添加一个校验位，使得包括校验位共9位里面有-奇数个“1”
    偶校验方案：添加一个校验位，使得包括校验位共9位里面有-偶数个“1”
    
- **接收端**做以下校验：
    
    统计传来的这份数据的9位中“1”的总个数是为奇还是为偶。若和发送前一样，则表示奇偶校验通过，否则表示数据发生位错，丢弃之。
    

【例题】 

- 例题如下：
    
    对于10000001，使用奇校验方案，则发送方发送110000001。
    
    若接收方收到后判断为“奇校验通过，偶校验不通过”，则表示接受到的数据中有奇数个1，与发送时相同，故奇偶校验通过。
    

### 2-**CRC循环冗余码检错**

【定义】

通过在帧数据后面加上n位循环冗余码（又叫帧检测序列，FCS），检查是否发生位错。

其核心是基于二进制除法，而因为这种除法可以通过硬件实现，所以该方案效率较高。

【内容】

- **发送端**
    
    1、收发双方先商定一个多项式G(x)
    
    2、在要发送的源数据末尾扩展k位（k为G(x)的阶数），这些扩展位的值被初始设置为0
    
    3、将扩展后的源数据去异或地除以多项式，最终得到一个余数，将该余数作为拓展位的值
    

> 也就相当于这个被除数自身左移k位后再加上了该余数，这样得到的结果理论将上为G(x)的$2^{k}+1$倍，也就是说该结果将整除G(x)
> 
- **接收端**
    
    接收端再将传送的数据去异或除以多项式G(x)。
    
    若数据不发生位错则应该整除，所以若不整除则表示数据位错，丢弃之
    

【例题】

- 例题如下：
    
    某客户端要发送数据1101011011，采用CRC校验，约定的多项式为10011，求最终发送的数据是多少？
    
    解：
    
    对源数据进行扩展后进行二进制除法如下：
    
    ![Untitled](%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%20102bf1941ce44abd9ce770785c92d093/Untitled%202.png)
    
    余数填入拓展位，得：11010110111110
    

### 3-海明码检错

【定义】

通过在有效信息中插入几个校验位，并把每个奇偶校验位进行分配，分配到几个奇偶校验组中

其可以实现在1位数据发生位错的情况下定位出出错位置，在2位数据发生位错的情况下发出报错

【内容】

**1、设定检验位个数**

一般来说，发送2~4位信息需要3位校验码，发送5~11位信息需要4位校验码

**2、设定方格，填入校验位和原始数据**

以1DWORD（8位）的“01001101”为例，校验位为4位，所以先设置8+4=12个方格：

![Untitled](%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%20102bf1941ce44abd9ce770785c92d093/Untitled%203.png)

令从右往左数第$2^{n}$个方格为校验位，记为$P_{n+1}$：

![Untitled](%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%20102bf1941ce44abd9ce770785c92d093/Untitled%204.png)

其他位填入原始数据即可：

![Untitled](%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%20102bf1941ce44abd9ce770785c92d093/Untitled%205.png)

**3、分配校验组，通过校验组确定校验位的值**

- 划1隔1，形成P1的校验组，通过在组内形成偶校验确定P1的值
- 划2隔2，形成P2的校验组，通过在组内形成偶校验确定P2的值
- 划4隔4，形成P3的校验组，通过在组内形成偶校验确定P3的值
- 划8隔8，形成P4的校验组，通过在组内形成偶校验确定P4的值

> 如下图：
> 
> 
> ![确定P1的校验组+确定P1的值](%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%20102bf1941ce44abd9ce770785c92d093/Untitled%206.png)
> 
> 确定P1的校验组+确定P1的值
> 
> ![确定P2、P3、P4的校验组](%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%20102bf1941ce44abd9ce770785c92d093/Untitled%207.png)
> 
> 确定P2、P3、P4的校验组
>